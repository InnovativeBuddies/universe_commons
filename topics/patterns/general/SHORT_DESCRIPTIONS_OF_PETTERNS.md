# Краткие описания паттернов

## 1. Порождающие паттерны (Creational Patterns)

### 1.1. Singleton (Одиночка)
Обеспечивает создание единственного экземпляра класса и предоставляет глобальную точку доступа к нему.

### 1.2. Factory Method (Фабричный метод)
Определяет интерфейс для создания объектов, но позволяет подклассам изменять тип создаваемого объекта.

### 1.3. Abstract Factory (Абстрактная фабрика)
Предоставляет интерфейс для создания семейств связанных или зависимых объектов, не специфицируя их конкретные классы.

### 1.4. Builder (Строитель)
Отделяет конструирование сложного объекта от его представления, так что один и тот же процесс конструирования может создавать различные представления.

### 1.5. Prototype (Прототип)
Создает новые объекты, копируя существующие экземпляры, избегая при этом наследования класса.

## 2. Структурные паттерны (Structural Patterns)

### 2.1. Adapter (Адаптер)
Позволяет объектам с несовместимыми интерфейсами работать вместе.

### 2.2. Decorator (Декоратор)
Динамически добавляет дополнительные обязанности объекту.

### 2.3. Facade (Фасад)
Предоставляет унифицированный интерфейс к группе интерфейсов в подсистеме, облегчая её использование.

### 2.4. Composite (Компоновщик)
Компонует объекты в древовидные структуры для представления иерархий "часть-целое".

### 2.5. Proxy (Заместитель)
Предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (например, для управления доступом или кэширования).

## 3. Поведенческие паттерны (Behavioral Patterns)

### 3.1. Observer (Наблюдатель)
Определяет зависимость "один ко многим" между объектами таким образом, что при изменении состояния одного объекта все зависимые объекты уведомляются и обновляются автоматически.

### 3.2. Strategy (Стратегия)
Определяет семейство алгоритмов, инкапсулирует их и делает их взаимозаменяемыми.

### 3.3. Command (Команда)
Инкапсулирует запрос как объект, позволяя параметризовать клиентов с разными запросами, очередями или логами запросов, а также поддерживать отмену операций.

### 3.4. Chain of Responsibility (Цепочка обязанностей)
Передает запрос по цепочке обработчиков, где каждый обработчик решает, обрабатывать запрос или передать его следующему по цепочке.

### 3.5. Mediator (Посредник)
Определяет объект, который инкапсулирует способ взаимодействия множества объектов, предотвращая прямую связь между объектами.

### 3.6. Template Method (Шаблонный метод)
Определяет скелет алгоритма в методе, перекладывая определение некоторых шагов алгоритма на подклассы.

## 4. Конкурентные паттерны (Concurrency Patterns)

### 4.1. Thread Pool (Пул потоков)
Множество потоков, которые могут использоваться для выполнения задач, вместо создания нового потока для каждой задачи.

### 4.2. Producer-Consumer (Производитель-потребитель)
Разделяет задачи на производство данных и их потребление, позволяя производителям и потребителям работать асинхронно.

### 4.3. Observer (Наблюдатель)
(В контексте многопоточности) Позволяет одному или нескольким потокам быть уведомленными о событиях, происходящих в другом потоке.

## 5. Архитектурные паттерны (Architectural Patterns)

### 5.1. MVC (Model-View-Controller)
Разделяет приложение на три основные логические компоненты: модель, представление и контроллер.

### 5.2. Microservices (Микросервисы)
Архитектурный стиль, при котором приложение состоит из небольших независимых сервисов, которые взаимодействуют друг с другом через API.

### 5.3. Event-Driven Architecture (Событийно-ориентированная архитектура)
Архитектура, в которой компоненты системы взаимодействуют путем обмена событиями.
